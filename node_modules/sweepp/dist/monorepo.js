"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.detectMonorepo = detectMonorepo;
exports.findPackageForFile = findPackageForFile;
exports.resolveWorkspaceImport = resolveWorkspaceImport;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const yaml_1 = __importDefault(require("yaml"));
/**
 * Detect if the current directory is a monorepo and what type
 */
function detectMonorepo(rootDir) {
    const config = {
        type: 'none',
        root: rootDir,
        packages: []
    };
    // Check for pnpm workspace
    const pnpmWorkspacePath = path_1.default.join(rootDir, 'pnpm-workspace.yaml');
    if (fs_1.default.existsSync(pnpmWorkspacePath)) {
        config.type = 'pnpm';
        config.packages = getPnpmWorkspacePackages(rootDir, pnpmWorkspacePath);
        return config;
    }
    // Check for turbo.json (turborepo)
    const turboJsonPath = path_1.default.join(rootDir, 'turbo.json');
    if (fs_1.default.existsSync(turboJsonPath)) {
        config.type = 'turborepo';
        // Turborepo can use any package manager, check root package.json for workspaces
        config.packages = getPackageJsonWorkspaces(rootDir);
        return config;
    }
    // Check for package.json workspaces (npm/yarn)
    const packageJsonPath = path_1.default.join(rootDir, 'package.json');
    if (fs_1.default.existsSync(packageJsonPath)) {
        try {
            const packageJson = JSON.parse(fs_1.default.readFileSync(packageJsonPath, 'utf8'));
            if (packageJson.workspaces) {
                config.type = Array.isArray(packageJson.workspaces) ? 'npm' : 'yarn';
                config.packages = getPackageJsonWorkspaces(rootDir);
                return config;
            }
        }
        catch (err) {
            // Not a valid package.json or no workspaces
        }
    }
    return config;
}
/**
 * Parse pnpm-workspace.yaml and find all packages
 */
function getPnpmWorkspacePackages(rootDir, workspacePath) {
    try {
        const content = fs_1.default.readFileSync(workspacePath, 'utf8');
        const config = yaml_1.default.parse(content);
        if (!config.packages || !Array.isArray(config.packages)) {
            return [];
        }
        return expandWorkspaceGlobs(rootDir, config.packages);
    }
    catch (err) {
        console.error('Error parsing pnpm-workspace.yaml:', err);
        return [];
    }
}
/**
 * Parse package.json workspaces (npm/yarn/turborepo)
 */
function getPackageJsonWorkspaces(rootDir) {
    const packageJsonPath = path_1.default.join(rootDir, 'package.json');
    try {
        const packageJson = JSON.parse(fs_1.default.readFileSync(packageJsonPath, 'utf8'));
        let workspacePatterns = [];
        if (Array.isArray(packageJson.workspaces)) {
            workspacePatterns = packageJson.workspaces;
        }
        else if (packageJson.workspaces?.packages) {
            workspacePatterns = packageJson.workspaces.packages;
        }
        else {
            return [];
        }
        return expandWorkspaceGlobs(rootDir, workspacePatterns);
    }
    catch (err) {
        return [];
    }
}
/**
 * Expand glob patterns to actual package directories
 */
function expandWorkspaceGlobs(rootDir, patterns) {
    const packages = [];
    for (const pattern of patterns) {
        // Handle negation patterns
        if (pattern.startsWith('!')) {
            continue;
        }
        // Simple glob expansion for common patterns like "packages/*" or "apps/*"
        if (pattern.includes('*')) {
            const parts = pattern.split('/');
            const baseDir = parts[0];
            const basePath = path_1.default.join(rootDir, baseDir);
            if (fs_1.default.existsSync(basePath) && fs_1.default.statSync(basePath).isDirectory()) {
                const entries = fs_1.default.readdirSync(basePath);
                for (const entry of entries) {
                    const entryPath = path_1.default.join(basePath, entry);
                    const packageJsonPath = path_1.default.join(entryPath, 'package.json');
                    if (fs_1.default.existsSync(packageJsonPath) && fs_1.default.statSync(entryPath).isDirectory()) {
                        try {
                            const packageJson = JSON.parse(fs_1.default.readFileSync(packageJsonPath, 'utf8'));
                            packages.push({
                                name: packageJson.name || entry,
                                path: entryPath,
                                packageJson
                            });
                        }
                        catch (err) {
                            // Invalid package.json, skip
                        }
                    }
                }
            }
        }
        else {
            // Direct path
            const packagePath = path_1.default.join(rootDir, pattern);
            const packageJsonPath = path_1.default.join(packagePath, 'package.json');
            if (fs_1.default.existsSync(packageJsonPath)) {
                try {
                    const packageJson = JSON.parse(fs_1.default.readFileSync(packageJsonPath, 'utf8'));
                    packages.push({
                        name: packageJson.name || pattern,
                        path: packagePath,
                        packageJson
                    });
                }
                catch (err) {
                    // Invalid package.json, skip
                }
            }
        }
    }
    return packages;
}
/**
 * Check if a path is within any workspace package
 */
function findPackageForFile(filePath, monorepoConfig) {
    const normalizedFilePath = path_1.default.normalize(filePath);
    for (const pkg of monorepoConfig.packages) {
        const normalizedPkgPath = path_1.default.normalize(pkg.path);
        if (normalizedFilePath.startsWith(normalizedPkgPath)) {
            return pkg;
        }
    }
    return null;
}
/**
 * Resolve imports within monorepo (workspace protocol)
 */
function resolveWorkspaceImport(importPath, currentPackage, monorepoConfig) {
    // Handle workspace protocol: workspace:* or workspace:^version
    if (importPath.startsWith('workspace:')) {
        return null; // Workspace protocol references, not file paths
    }
    // Check if import is a package name that exists in the workspace
    for (const pkg of monorepoConfig.packages) {
        if (pkg.packageJson && pkg.packageJson.name === importPath) {
            // Found workspace package - resolve to its main entry or index
            const pkgMain = pkg.packageJson.main || pkg.packageJson.module || 'index.js';
            return path_1.default.join(pkg.path, pkgMain);
        }
        // Handle scoped imports like '@myorg/package/subpath'
        if (importPath.startsWith(pkg.packageJson?.name + '/')) {
            const subpath = importPath.substring(pkg.packageJson.name.length + 1);
            return path_1.default.join(pkg.path, subpath);
        }
    }
    return null;
}
