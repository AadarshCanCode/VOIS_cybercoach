"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.analyzeAndClean = analyzeAndClean;
const parser_1 = require("@babel/parser");
const traverse_1 = __importDefault(require("@babel/traverse"));
const generator_1 = __importDefault(require("@babel/generator"));
const t = __importStar(require("@babel/types"));
const promises_1 = __importDefault(require("fs/promises"));
const fs_1 = __importDefault(require("fs"));
const pathResolver_1 = require("./pathResolver");
function isTypeOnlySpecifier(spec) {
    // Babel marks type-only specifiers via importKind on declaration or spec.importKind
    return spec.importKind === 'type';
}
function collectUsedIdentifiers(ast) {
    const used = new Set();
    // Collect used identifiers, skipping import declarations entirely
    (0, traverse_1.default)(ast, {
        Identifier(path) {
            // Skip if we're inside an ImportDeclaration
            if (path.findParent(p => p.isImportDeclaration())) {
                return;
            }
            // Skip if this identifier is the left-hand side of a variable declaration
            // (i.e., the variable being declared, not being used)
            const parent = path.parent;
            if (t.isVariableDeclarator(parent) && parent.id === path.node) {
                return;
            }
            // Skip function parameter names, but allow usage within function bodies
            if (t.isFunctionDeclaration(parent) || t.isFunctionExpression(parent) || t.isArrowFunctionExpression(parent)) {
                if (parent.params.includes(path.node)) {
                    return;
                }
            }
            used.add(path.node.name);
        },
        TSTypeReference(path) {
            if (t.isIdentifier(path.node.typeName)) {
                used.add(path.node.typeName.name);
            }
        }
    });
    return used;
}
async function analyzeAndClean(filePath, dryRun, options = {}) {
    const code = await promises_1.default.readFile(filePath, 'utf8');
    let ast;
    try {
        ast = (0, parser_1.parse)(code, {
            sourceType: 'module',
            plugins: ['typescript', 'jsx']
        });
    }
    catch (err) {
        return {
            filePath,
            removed: [],
            originalImportDecls: 0,
            finalImportDecls: 0,
            changed: false,
            totalRemovedSpecifiers: 0
        };
    }
    const used = collectUsedIdentifiers(ast);
    // Detect presence of JSX so we can safely retain React default import
    let hasJSX = false;
    (0, traverse_1.default)(ast, {
        JSXElement() { hasJSX = true; },
        JSXFragment() { hasJSX = true; }
    });
    const removed = [];
    let originalImportDecls = 0;
    // Resolve path aliases if checking local imports
    const aliasMap = options.checkLocalImports && options.projectRoot
        ? (0, pathResolver_1.resolvePathAliases)(options.projectRoot)
        : new Map();
    (0, traverse_1.default)(ast, {
        ImportDeclaration(path) {
            originalImportDecls++;
            const decl = path.node;
            const importSource = decl.source.value;
            // Check if local import exists in project
            if (options.checkLocalImports && options.projectRoot) {
                const isLocal = (0, pathResolver_1.isLocalImport)(importSource) || aliasMap.has(importSource.split('/')[0]);
                if (isLocal) {
                    const resolvedPath = (0, pathResolver_1.resolveFullImportPath)(importSource, filePath, options.projectRoot, aliasMap, options.monorepoConfig);
                    if (!resolvedPath || !fs_1.default.existsSync(resolvedPath)) {
                        // The imported file doesn't exist, mark all specifiers as removable
                        if (decl.specifiers.length > 0) {
                            const allSpecifierNames = decl.specifiers.map(spec => spec.local.name);
                            removed.push({ source: importSource, specifiers: allSpecifierNames });
                            path.remove();
                            return;
                        }
                    }
                }
            }
            if (decl.specifiers.length === 0) {
                // Side-effect import like import 'foo'; keep it.
                return;
            }
            const remaining = [];
            const removedNames = [];
            decl.specifiers.forEach((spec) => {
                if (t.isImportSpecifier(spec)) {
                    const localName = spec.local.name;
                    const isTypeOnly = isTypeOnlySpecifier(spec);
                    const isUsed = used.has(localName);
                    if (!isUsed) {
                        removedNames.push(localName);
                    }
                    else {
                        remaining.push(spec);
                    }
                }
                else if (t.isImportDefaultSpecifier(spec)) {
                    const localName = spec.local.name;
                    // If JSX is present, retain React default import even if identifier unused (new JSX transform)
                    if (importSource === 'react' && hasJSX) {
                        remaining.push(spec);
                    }
                    else if (!used.has(localName)) {
                        removedNames.push(localName);
                    }
                    else {
                        remaining.push(spec);
                    }
                }
                else if (t.isImportNamespaceSpecifier(spec)) {
                    const localName = spec.local.name;
                    if (!used.has(localName)) {
                        removedNames.push(localName);
                    }
                    else {
                        remaining.push(spec);
                    }
                }
            });
            if (removedNames.length > 0) {
                removed.push({ source: decl.source.value, specifiers: removedNames });
            }
            if (remaining.length === 0) {
                // Remove entire declaration
                if (removedNames.length === decl.specifiers.length) {
                    path.remove();
                }
                else {
                    // Rare edge case fallback
                    decl.specifiers = [];
                }
            }
            else {
                // Filter specifiers
                decl.specifiers = remaining;
            }
        }
    });
    // Re-count remaining import declarations for accuracy
    let finalImportDecls = 0;
    (0, traverse_1.default)(ast, {
        ImportDeclaration() { finalImportDecls++; }
    });
    const changed = removed.some(r => r.specifiers.length > 0);
    let newCode;
    if (changed) {
        newCode = (0, generator_1.default)(ast, { retainLines: true, comments: true }).code;
        if (!dryRun && newCode !== undefined) {
            await promises_1.default.writeFile(filePath, newCode, 'utf8');
        }
    }
    const totalRemovedSpecifiers = removed.reduce((a, r) => a + r.specifiers.length, 0);
    return { filePath, removed, originalImportDecls, finalImportDecls, changed, totalRemovedSpecifiers, newCode };
}
