#!/usr/bin/env node
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const commander_1 = require("commander");
const chalk_1 = __importDefault(require("chalk"));
const path_1 = __importDefault(require("path"));
const analyzer_1 = require("./analyzer");
const fileUtils_1 = require("./fileUtils");
const unusedCode_1 = require("./unusedCode");
const monorepo_1 = require("./monorepo");
// Simple p-limit implementation to avoid dependency
function pLimit(concurrency) {
    const queue = [];
    let activeCount = 0;
    const next = () => {
        activeCount--;
        if (queue.length > 0) {
            queue.shift()();
        }
    };
    const run = async (fn, resolve, reject) => {
        activeCount++;
        try {
            const result = await fn();
            resolve(result);
        }
        catch (err) {
            reject(err);
        }
        finally {
            next();
        }
    };
    const enqueue = (fn, resolve, reject) => {
        queue.push(() => run(fn, resolve, reject));
        if (activeCount < concurrency) {
            const nextFn = queue.shift();
            if (nextFn)
                nextFn();
        }
    };
    return (fn) => new Promise((resolve, reject) => enqueue(fn, resolve, reject));
}
async function listUnusedImports(target, extensions, ignore, checkLocal, monorepoConfig) {
    const files = await (0, fileUtils_1.discoverFiles)(target, { root: process.cwd(), extensions, ignore });
    const projectRoot = process.cwd();
    const items = [];
    const limit = pLimit(10); // Concurrency limit
    const tasks = files.map(file => limit(async () => {
        try {
            const result = await (0, analyzer_1.analyzeAndClean)(file, true, {
                checkLocalImports: checkLocal,
                projectRoot,
                monorepoConfig
            });
            if (result.changed) {
                const flat = result.removed.flatMap(r => r.specifiers);
                items.push({ file, specifiers: flat });
            }
        }
        catch (error) {
            console.error(chalk_1.default.red(`Error analyzing ${file}:`), error);
        }
    }));
    await Promise.all(tasks);
    return items;
}
async function cleanUnusedImports(target, extensions, ignore, checkLocal, monorepoConfig) {
    const files = await (0, fileUtils_1.discoverFiles)(target, { root: process.cwd(), extensions, ignore });
    const projectRoot = process.cwd();
    let filesChanged = 0;
    let totalRemoved = 0;
    const limit = pLimit(10);
    const tasks = files.map(file => limit(async () => {
        try {
            const result = await (0, analyzer_1.analyzeAndClean)(file, false, {
                checkLocalImports: checkLocal,
                projectRoot,
                monorepoConfig
            });
            if (result.changed) {
                filesChanged++;
                const flat = result.removed.flatMap(r => r.specifiers);
                totalRemoved += flat.length;
                console.log(chalk_1.default.green(`✔ ${path_1.default.relative(process.cwd(), file)} removed: ${flat.join(', ')}`));
            }
        }
        catch (error) {
            console.error(chalk_1.default.red(`Error cleaning ${file}:`), error);
        }
    }));
    await Promise.all(tasks);
    return { filesChanged, totalSpecifiersRemoved: totalRemoved };
}
async function run() {
    const pkg = require('../package.json');
    const program = new commander_1.Command();
    program
        .name('sweepp')
        .description('Sweep unused imports and code from JS/TS projects')
        .version(pkg.version, '-v, --version', 'Show version')
        .alias('swp');
    const commonOptions = (cmd) => cmd
        .argument('[target]', 'Directory or file to scan', '.')
        .option('--ext <list>', 'Comma separated extensions', 'ts,tsx,js,jsx')
        .option('--ignore <list>', 'Comma separated ignore globs', '')
        .option('--check-local', 'Check if local imports exist in project (supports @/ and path aliases)', false);
    program
        .command('list')
        .description('List unused import specifiers')
        .addHelpText('after', '\nExample:\n  $ sweepp list src\n  $ sweepp list --ext ts,tsx')
        .argument('[target]', 'Directory or file to scan', '.')
        .option('--ext <list>', 'Comma separated extensions', 'ts,tsx,js,jsx')
        .option('--ignore <list>', 'Comma separated ignore globs', '')
        .option('--check-local', 'Check if local imports exist in project (supports @/ and path aliases)', false)
        .action(async (target, opts) => {
        try {
            const extensions = opts.ext.split(',').map((s) => s.trim()).filter(Boolean);
            const ignore = opts.ignore.split(',').map((s) => s.trim()).filter(Boolean);
            const checkLocal = opts.checkLocal || false;
            const monorepoConfig = (0, monorepo_1.detectMonorepo)(process.cwd());
            if (monorepoConfig.type !== 'none') {
                console.log(chalk_1.default.gray(`Detected ${monorepoConfig.type} monorepo with ${monorepoConfig.packages.length} package(s)\n`));
            }
            console.log(chalk_1.default.blue(`Scanning ${target}...`));
            const items = await listUnusedImports(target, extensions, ignore, checkLocal, monorepoConfig);
            if (items.length === 0) {
                console.log(chalk_1.default.green('No unused imports found.'));
                return;
            }
            console.log(chalk_1.default.bold.cyan('\nUnused Imports Report\n'));
            const maxFileLength = Math.min(Math.max(...items.map(it => path_1.default.relative(process.cwd(), it.file).length), 'File'.length), 60);
            const maxCountLength = Math.max(...items.map(it => it.specifiers.length.toString().length), 'Count'.length);
            const fileHeader = 'File'.padEnd(maxFileLength);
            const countHeader = 'Count'.padEnd(maxCountLength);
            const specsHeader = 'Unused Imports';
            console.log(chalk_1.default.bold.white(`${fileHeader}  ${countHeader}  ${specsHeader}`));
            console.log(chalk_1.default.gray('─'.repeat(maxFileLength + maxCountLength + 50)));
            for (const it of items) {
                let fileName = path_1.default.relative(process.cwd(), it.file);
                if (fileName.length > maxFileLength) {
                    fileName = '...' + fileName.slice(-(maxFileLength - 3));
                }
                const count = it.specifiers.length.toString().padEnd(maxCountLength);
                const specs = it.specifiers.join(', ');
                console.log(`${chalk_1.default.yellow(fileName.padEnd(maxFileLength))}  ${chalk_1.default.cyan(count)}  ${chalk_1.default.gray(specs)}`);
            }
            const totalSpecifiers = items.reduce((a, b) => a + b.specifiers.length, 0);
            console.log(chalk_1.default.gray('─'.repeat(maxFileLength + maxCountLength + 50)));
            console.log(chalk_1.default.bold(`\nSummary: ${chalk_1.default.yellow(items.length)} file(s) with ${chalk_1.default.cyan(totalSpecifiers)} unused import(s)\n`));
        }
        catch (err) {
            console.error(chalk_1.default.red('Error:'), err);
            process.exit(1);
        }
    });
    program
        .command('clean')
        .description('Remove unused imports and show summary')
        .argument('[target]', 'Directory or file to scan', '.')
        .option('--ext <list>', 'Comma separated extensions', 'ts,tsx,js,jsx')
        .option('--ignore <list>', 'Comma separated ignore globs', '')
        .option('--check-local', 'Check if local imports exist in project (supports @/ and path aliases)', false)
        .action(async (target, opts) => {
        try {
            const extensions = opts.ext.split(',').map((s) => s.trim()).filter(Boolean);
            const ignore = opts.ignore.split(',').map((s) => s.trim()).filter(Boolean);
            const checkLocal = opts.checkLocal || false;
            const monorepoConfig = (0, monorepo_1.detectMonorepo)(process.cwd());
            if (monorepoConfig.type !== 'none') {
                console.log(chalk_1.default.gray(`Detected ${monorepoConfig.type} monorepo with ${monorepoConfig.packages.length} package(s)\n`));
            }
            console.log(chalk_1.default.blue(`Cleaning ${target}...`));
            const summary = await cleanUnusedImports(target, extensions, ignore, checkLocal, monorepoConfig);
            console.log('\n' + chalk_1.default.bold('Clean Summary'));
            console.log(`Files changed: ${summary.filesChanged}`);
            console.log(`Total specifiers removed: ${summary.totalSpecifiersRemoved}`);
        }
        catch (err) {
            console.error(chalk_1.default.red('Error:'), err);
            process.exit(1);
        }
    });
    program
        .command('unused-code')
        .alias('dead')
        .alias('unuse')
        .description('List potentially unused exported or top-level code (safe preview)')
        .argument('[target]', 'Directory or file to scan', '.')
        .option('--ext <list>', 'Comma separated extensions', 'ts,tsx,js,jsx')
        .option('--ignore <list>', 'Comma separated ignore globs', '')
        .action(async (target, opts) => {
        try {
            const extensions = opts.ext.split(',').map((s) => s.trim()).filter(Boolean);
            const ignore = opts.ignore.split(',').map((s) => s.trim()).filter(Boolean);
            const monorepoConfig = (0, monorepo_1.detectMonorepo)(process.cwd());
            if (monorepoConfig.type !== 'none') {
                console.log(chalk_1.default.gray(`Detected ${monorepoConfig.type} monorepo with ${monorepoConfig.packages.length} package(s)\n`));
            }
            console.log(chalk_1.default.blue(`Scanning for unused code in ${target}...`));
            const items = await (0, unusedCode_1.findUnusedCode)(target, extensions, ignore, monorepoConfig);
            if (items.length === 0) {
                console.log(chalk_1.default.green.bold('✔ No unused code candidates found.'));
                return;
            }
            const rel = (f) => path_1.default.relative(process.cwd(), f);
            const allowedRoots = ['src', 'apps', 'packages'];
            console.log(chalk_1.default.bold.cyan('\nUnused Code Candidates\n'));
            for (const it of items) {
                const relFile = rel(it.file);
                // Only show files from main source folders if scanning root
                if (target === '.' && !allowedRoots.some(root => relFile.startsWith(root + path_1.default.sep) || relFile === root)) {
                    // Optional: skip files outside common source dirs if scanning root to reduce noise
                    // But if user specified target, show everything.
                    // Keeping original logic's spirit but making it safer.
                }
                console.log(`${chalk_1.default.yellow(relFile)} ${chalk_1.default.white(it.name)} ${chalk_1.default.gray(it.kind)} ${it.exported ? chalk_1.default.magenta('exported') : ''}`);
            }
            console.log(`\nSummary: ${items.length} unused code candidate(s).`);
            console.log(chalk_1.default.gray('Note: Heuristic detection. Review before removal.'));
        }
        catch (err) {
            console.error(chalk_1.default.red('Error:'), err);
            process.exit(1);
        }
    });
    // Default action if no command provided
    program.action(() => {
        program.help();
    });
    await program.parseAsync(process.argv);
}
run().catch(err => {
    console.error(chalk_1.default.red('Fatal Error:'), err);
    process.exit(1);
});
