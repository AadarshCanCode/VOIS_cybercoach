"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.findUnusedFiles = findUnusedFiles;
exports.formatUnusedTable = formatUnusedTable;
const parser_1 = require("@babel/parser");
const traverse_1 = __importDefault(require("@babel/traverse"));
const promises_1 = __importDefault(require("fs/promises"));
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
function resolveImport(fromFile, source, extensions) {
    if (!source.startsWith('.') && !source.startsWith('/'))
        return null; // external
    const baseDir = path_1.default.dirname(fromFile);
    const raw = path_1.default.resolve(baseDir, source);
    const tryPaths = [];
    // If source already has extension
    if (extensions.some(ext => raw.endsWith('.' + ext.replace(/^\./, '')))) {
        tryPaths.push(raw);
    }
    else {
        for (const ext of extensions) {
            const clean = ext.startsWith('.') ? ext.slice(1) : ext;
            tryPaths.push(`${raw}.${clean}`);
        }
        // index file inside directory
        for (const ext of extensions) {
            const clean = ext.startsWith('.') ? ext.slice(1) : ext;
            tryPaths.push(path_1.default.join(raw, `index.${clean}`));
        }
    }
    for (const p of tryPaths) {
        if (fs_1.default.existsSync(p))
            return path_1.default.normalize(p);
    }
    return null;
}
async function buildGraph(files, extensions) {
    const map = new Map();
    for (const file of files) {
        let ast = null;
        try {
            const code = await promises_1.default.readFile(file, 'utf8');
            ast = (0, parser_1.parse)(code, { sourceType: 'module', plugins: ['typescript', 'jsx'] });
        }
        catch {
            map.set(file, { imports: [], exports: 0 });
            continue;
        }
        const imports = [];
        let exportsCount = 0;
        (0, traverse_1.default)(ast, {
            ImportDeclaration(p) {
                const resolved = resolveImport(file, p.node.source.value, extensions);
                if (resolved)
                    imports.push(resolved);
            },
            ExportNamedDeclaration() { exportsCount++; },
            ExportDefaultDeclaration() { exportsCount++; }
        });
        map.set(file, { imports, exports: exportsCount });
    }
    return map;
}
async function findUnusedFiles(files, extensions, entryFiles = []) {
    const entryAbs = new Set(entryFiles.map(f => path_1.default.normalize(path_1.default.resolve(process.cwd(), f))));
    const graph = await buildGraph(files, extensions);
    const importedSet = new Set();
    for (const info of graph.values()) {
        for (const imp of info.imports)
            importedSet.add(path_1.default.normalize(imp));
    }
    const unused = [];
    for (const file of files) {
        if (!importedSet.has(path_1.default.normalize(file))) {
            // skip entry CLI file
            if (/cli\.(t|j)sx?$/.test(path_1.default.basename(file)))
                continue;
            if (entryAbs.has(path_1.default.normalize(file)))
                continue; // user-declared entry
            const stat = fs_1.default.statSync(file);
            const info = graph.get(file);
            unused.push({
                file,
                relative: path_1.default.relative(process.cwd(), file),
                sizeKB: +(stat.size / 1024).toFixed(2),
                importCount: info.imports.length,
                exportCount: info.exports
            });
        }
    }
    // Sort largest first
    unused.sort((a, b) => b.sizeKB - a.sizeKB);
    return unused;
}
function formatUnusedTable(rows) {
    if (rows.length === 0)
        return 'No unused files detected.';
    const chalk = require('chalk');
    const headers = ['File', 'Size(KB)', 'Imports', 'Exports'];
    const colWidths = [
        Math.max(...rows.map(r => r.relative.length), headers[0].length),
        headers[1].length,
        headers[2].length,
        headers[3].length
    ];
    const pad = (str, len) => str + ' '.repeat(Math.max(0, len - str.length));
    let out = '';
    out += chalk.bold(headers.map((h, i) => pad(h, colWidths[i])).join('  ')) + '\n';
    out += headers.map((_, i) => '-'.repeat(colWidths[i])).join('  ') + '\n';
    for (const r of rows) {
        out += [
            chalk.yellow(pad(r.relative, colWidths[0])),
            chalk.magenta(pad(r.sizeKB.toString(), colWidths[1])),
            chalk.cyan(pad(r.importCount.toString(), colWidths[2])),
            chalk.green(pad(r.exportCount.toString(), colWidths[3]))
        ].join('  ') + '\n';
    }
    return out;
}
