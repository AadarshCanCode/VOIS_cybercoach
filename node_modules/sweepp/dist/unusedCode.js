"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.findUnusedCode = findUnusedCode;
const parser_1 = require("@babel/parser");
const traverse_1 = __importDefault(require("@babel/traverse"));
const t = __importStar(require("@babel/types"));
const path_1 = __importDefault(require("path"));
const promises_1 = __importDefault(require("fs/promises"));
const fileUtils_1 = require("./fileUtils");
const pathResolver_1 = require("./pathResolver");
const DEFAULT_IGNORE = [
    'node_modules',
    'dist',
    'build',
    'out',
    '.next',
    '.vercel',
    '.git',
    'coverage',
    'public',
    'static',
    'storybook-static',
    'tmp',
    'temp',
    '.cache',
    '.expo',
    '.idea',
    '.vscode'
];
const nextIgnores = [
    '**/pages/_app.*',
    '**/pages/_document.*',
    '**/pages/_error.*',
    '**/pages/_middleware.*',
    '**/pages/_api/**',
    '**/pages/_*',
    '**/app/_*',
    '**/app/layout.*',
    '**/app/error.*',
    '**/app/loading.*',
    '**/app/not-found.*',
    '**/app/head.*',
    '**/app/global-error.*'
];
// (stray/incorrect) Remove this line, only use allIgnores inside findUnusedCode
function collectFileAnalysis(code) {
    let ast;
    try {
        ast = (0, parser_1.parse)(code, { sourceType: 'module', plugins: ['typescript', 'jsx'] });
        // Only scan user codebase folders, never node_modules or build/system folders
        const DEFAULT_IGNORE = [
            'node_modules',
            'dist',
            'build',
            'out',
            '.next',
            '.vercel',
            '.git',
            'coverage',
            'public',
            'static',
            'storybook-static',
            'tmp',
            'temp',
            '.cache',
            '.expo',
            '.idea',
            '.vscode'
        ];
    }
    catch {
        return { declarations: [], used: new Set(), exports: new Set(), defaultExport: null, reExports: new Set() };
    }
    const declarations = [];
    const used = new Set();
    const exports = new Set();
    let defaultExport = null;
    const reExports = new Set();
    (0, traverse_1.default)(ast, {
        Identifier(path) {
            if (path.findParent(p => p.isImportDeclaration()))
                return;
            const parent = path.parent;
            if (t.isVariableDeclarator(parent) && parent.id === path.node)
                return;
            if ((t.isFunctionDeclaration(parent) || t.isFunctionExpression(parent) || t.isArrowFunctionExpression(parent)) && parent.params.includes(path.node))
                return;
            used.add(path.node.name);
        },
        TSTypeReference(path) {
            if (t.isIdentifier(path.node.typeName))
                used.add(path.node.typeName.name);
        }
    });
    (0, traverse_1.default)(ast, {
        ExportDefaultDeclaration(path) {
            // Track default export name if possible
            const node = path.node;
            if (t.isIdentifier(node.declaration)) {
                defaultExport = node.declaration.name;
            }
            else if (t.isFunctionDeclaration(node.declaration) && node.declaration.id) {
                defaultExport = node.declaration.id.name;
            }
            else if (t.isClassDeclaration(node.declaration) && node.declaration.id) {
                defaultExport = node.declaration.id.name;
            }
            else {
                defaultExport = 'default';
            }
        },
        ExportNamedDeclaration(path) {
            const node = path.node;
            if (node.declaration) {
                if (t.isFunctionDeclaration(node.declaration) && node.declaration.id) {
                    declarations.push({ name: node.declaration.id.name, kind: 'function', exported: true, startLine: node.declaration.loc?.start.line ?? null, endLine: node.declaration.loc?.end.line ?? null });
                    exports.add(node.declaration.id.name);
                }
                else if (t.isClassDeclaration(node.declaration) && node.declaration.id) {
                    declarations.push({ name: node.declaration.id.name, kind: 'class', exported: true, startLine: node.declaration.loc?.start.line ?? null, endLine: node.declaration.loc?.end.line ?? null });
                    exports.add(node.declaration.id.name);
                }
                else if (t.isVariableDeclaration(node.declaration)) {
                    node.declaration.declarations.forEach(d => {
                        if (t.isIdentifier(d.id)) {
                            declarations.push({
                                name: d.id.name,
                                kind: 'variable',
                                exported: true,
                                startLine: d.loc?.start.line ?? node.declaration?.loc?.start.line ?? null,
                                endLine: d.loc?.end.line ?? node.declaration?.loc?.end.line ?? null
                            });
                            exports.add(d.id.name);
                        }
                    });
                }
                else if (t.isTSTypeAliasDeclaration(node.declaration) && t.isIdentifier(node.declaration.id)) {
                    declarations.push({ name: node.declaration.id.name, kind: 'type', exported: true, startLine: node.declaration.loc?.start.line ?? null, endLine: node.declaration.loc?.end.line ?? null });
                    exports.add(node.declaration.id.name);
                }
                else if (t.isTSInterfaceDeclaration(node.declaration) && t.isIdentifier(node.declaration.id)) {
                    declarations.push({ name: node.declaration.id.name, kind: 'interface', exported: true, startLine: node.declaration.loc?.start.line ?? null, endLine: node.declaration.loc?.end.line ?? null });
                    exports.add(node.declaration.id.name);
                }
            }
            if (node.specifiers) {
                node.specifiers.forEach(spec => {
                    if (t.isExportSpecifier(spec)) {
                        const name = spec.local.name;
                        const existing = declarations.find(d => d.name === name);
                        if (existing) {
                            existing.exported = true;
                        }
                        else {
                            declarations.push({ name, kind: 'variable', exported: true, startLine: spec.loc?.start.line ?? null, endLine: spec.loc?.end.line ?? null }); // kind unknown; treat as variable
                        }
                        exports.add(name);
                    }
                });
            }
            // Track re-exports: export { foo } from './bar'
            if (node.source && node.specifiers) {
                node.specifiers.forEach(spec => {
                    if (t.isExportSpecifier(spec)) {
                        const exportedName = t.isIdentifier(spec.exported) ? spec.exported.name : spec.exported.value;
                        reExports.add(exportedName);
                    }
                });
            }
        },
        FunctionDeclaration(path) {
            if (!path.node.id)
                return;
            if (!declarations.some(d => d.name === path.node.id.name)) {
                declarations.push({ name: path.node.id.name, kind: 'function', exported: false, startLine: path.node.loc?.start.line ?? null, endLine: path.node.loc?.end.line ?? null });
            }
        },
        ClassDeclaration(path) {
            if (!path.node.id)
                return;
            if (!declarations.some(d => d.name === path.node.id.name)) {
                declarations.push({ name: path.node.id.name, kind: 'class', exported: false, startLine: path.node.loc?.start.line ?? null, endLine: path.node.loc?.end.line ?? null });
            }
        },
        VariableDeclaration(path) {
            path.node.declarations.forEach(d => {
                if (t.isIdentifier(d.id)) {
                    const varName = d.id.name;
                    if (!declarations.some(dd => dd.name === varName)) {
                        declarations.push({
                            name: varName,
                            kind: 'variable',
                            exported: false,
                            startLine: d.loc?.start.line ?? path.node.loc?.start.line ?? null,
                            endLine: d.loc?.end.line ?? path.node.loc?.end.line ?? null
                        });
                    }
                }
            });
        },
        TSTypeAliasDeclaration(path) {
            if (t.isIdentifier(path.node.id) && !declarations.some(dd => dd.name === path.node.id.name)) {
                declarations.push({ name: path.node.id.name, kind: 'type', exported: false, startLine: path.node.loc?.start.line ?? null, endLine: path.node.loc?.end.line ?? null });
            }
        },
        TSInterfaceDeclaration(path) {
            if (t.isIdentifier(path.node.id) && !declarations.some(dd => dd.name === path.node.id.name)) {
                declarations.push({ name: path.node.id.name, kind: 'interface', exported: false, startLine: path.node.loc?.start.line ?? null, endLine: path.node.loc?.end.line ?? null });
            }
        }
    });
    return { declarations, used, exports, defaultExport, reExports };
}
async function findUnusedCode(target, extensions, ignore, monorepoConfig) {
    // Add built-in Next.js ignore patterns
    // Always strictly ignore system folders regardless of user input
    const allIgnores = Array.from(new Set([...(ignore || []), ...DEFAULT_IGNORE, ...nextIgnores]));
    const projectRoot = process.cwd();
    const aliasMap = (0, pathResolver_1.resolvePathAliases)(projectRoot);
    const files = await (0, fileUtils_1.discoverFiles)(target, { root: projectRoot, extensions, ignore: allIgnores });
    // Batch file reads with concurrency limit to avoid EMFILE
    const BATCH_SIZE = 32;
    async function batchReadFiles(fileList) {
        const results = [];
        for (let i = 0; i < fileList.length; i += BATCH_SIZE) {
            const batch = fileList.slice(i, i + BATCH_SIZE);
            const batchResults = await Promise.all(batch.map(async (f) => {
                try {
                    return await promises_1.default.readFile(f, 'utf8');
                }
                catch (err) {
                    const code = err?.code || (err instanceof Error ? err.message : String(err));
                    console.warn(`[sweepp] Skipped unreadable file: ${f} (${code})`);
                    return '';
                }
            }));
            results.push(...batchResults);
        }
        return results;
    }
    const fileContents = await batchReadFiles(files);
    const fileAnalyses = {};
    const asts = {};
    files.forEach((file, i) => {
        try {
            if (!fileContents[i])
                throw new Error('Empty file');
            asts[file] = (0, parser_1.parse)(fileContents[i], { sourceType: 'module', plugins: ['typescript', 'jsx'] });
            fileAnalyses[file] = collectFileAnalysis(fileContents[i]);
        }
        catch (err) {
            asts[file] = null;
            fileAnalyses[file] = { declarations: [], used: new Set(), exports: new Set(), defaultExport: null, reExports: new Set() };
            if (fileContents[i]) {
                const code = err?.code || (err instanceof Error ? err.message : String(err));
                console.warn(`[sweepp] Skipped unparseable file: ${file} (${code})`);
            }
        }
    });
    // Build import/export dependency graph in a single pass
    files.forEach(file => {
        const ast = asts[file];
        if (!ast)
            return;
        (0, traverse_1.default)(ast, {
            ImportDeclaration(p) {
                const src = p.node.source.value;
                const isLocal = (0, pathResolver_1.isLocalImport)(src) || aliasMap.has(src.split('/')[0]);
                if (!isLocal)
                    return;
                const resolved = (0, pathResolver_1.resolveFullImportPath)(src, file, projectRoot, aliasMap, monorepoConfig);
                if (!resolved || !fileAnalyses[resolved])
                    return;
                p.node.specifiers.forEach(spec => {
                    if (t.isImportSpecifier(spec)) {
                        const importedName = t.isIdentifier(spec.imported) ? spec.imported.name : spec.imported.value;
                        fileAnalyses[resolved].used.add(importedName);
                    }
                    else if (t.isImportNamespaceSpecifier(spec)) {
                        fileAnalyses[resolved].exports.forEach(name => fileAnalyses[resolved].used.add(name));
                    }
                    else if (t.isImportDefaultSpecifier(spec)) {
                        if (fileAnalyses[resolved].defaultExport) {
                            fileAnalyses[resolved].used.add(fileAnalyses[resolved].defaultExport);
                        }
                    }
                });
            }
        });
    });
    // Mark re-exported symbols as used if imported elsewhere
    files.forEach(file => {
        const analysis = fileAnalyses[file];
        if (!analysis)
            return;
        for (const reExport of analysis.reExports) {
            if (analysis.used.has(reExport))
                continue;
            for (const otherFile of files) {
                if (otherFile === file)
                    continue;
                if (fileAnalyses[otherFile]?.used.has(reExport)) {
                    analysis.used.add(reExport);
                    break;
                }
            }
        }
    });
    // Collect unused code
    const unused = [];
    for (const [file, analysis] of Object.entries(fileAnalyses)) {
        const rel = path_1.default.relative(projectRoot, file);
        const isNextPages = /\\pages\\|\/pages\//.test(rel) || /\\app\\|\/app\//.test(rel);
        for (const decl of analysis.declarations) {
            if (isNextPages && decl.exported)
                continue;
            if (!analysis.used.has(decl.name)) {
                unused.push({ file, name: decl.name, kind: decl.kind, exported: decl.exported, startLine: decl.startLine, endLine: decl.endLine });
            }
        }
    }
    return unused.sort((a, b) => a.file.localeCompare(b.file) || a.name.localeCompare(b.name));
}
