"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolvePathAliases = resolvePathAliases;
exports.resolveImportPath = resolveImportPath;
exports.isLocalImport = isLocalImport;
exports.resolveFullImportPath = resolveFullImportPath;
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
const monorepo_1 = require("./monorepo");
/**
 * Resolve TypeScript/JavaScript path aliases from tsconfig.json or jsconfig.json
 */
function resolvePathAliases(projectRoot) {
    const aliasMap = new Map();
    // Try to read tsconfig.json first, then jsconfig.json
    const configFiles = ['tsconfig.json', 'jsconfig.json'];
    for (const configFile of configFiles) {
        const configPath = path_1.default.join(projectRoot, configFile);
        if (!fs_1.default.existsSync(configPath)) {
            continue;
        }
        try {
            const configContent = fs_1.default.readFileSync(configPath, 'utf8');
            // Simple JSON parsing (ignoring comments for now)
            const config = JSON.parse(configContent.replace(/\/\*[\s\S]*?\*\//g, '').replace(/\/\/.*/g, ''));
            if (config.compilerOptions?.paths) {
                const baseUrl = config.compilerOptions.baseUrl || '.';
                const baseUrlResolved = path_1.default.resolve(projectRoot, baseUrl);
                for (const [alias, targets] of Object.entries(config.compilerOptions.paths)) {
                    if (Array.isArray(targets) && targets.length > 0) {
                        // Remove the /* suffix from alias and target
                        const cleanAlias = alias.replace(/\/\*$/, '');
                        const cleanTarget = targets[0].replace(/\/\*$/, '');
                        const resolvedPath = path_1.default.resolve(baseUrlResolved, cleanTarget);
                        aliasMap.set(cleanAlias, resolvedPath);
                    }
                }
            }
            break; // Stop after first valid config file
        }
        catch (err) {
            // Continue to next config file
        }
    }
    return aliasMap;
}
/**
 * Resolve an import path that might contain an alias
 */
function resolveImportPath(importPath, aliasMap) {
    // Check if import starts with any alias
    for (const [alias, resolvedPath] of aliasMap.entries()) {
        if (importPath === alias || importPath.startsWith(alias + '/')) {
            const remainder = importPath.substring(alias.length);
            return resolvedPath + remainder;
        }
    }
    return importPath;
}
/**
 * Check if an import is a relative/absolute path (not a node_modules package)
 */
function isLocalImport(importPath) {
    return importPath.startsWith('.') || importPath.startsWith('/') || importPath.startsWith('@/');
}
/**
 * Resolve the full file path for an import statement
 */
function resolveFullImportPath(importPath, currentFilePath, projectRoot, aliasMap, monorepoConfig) {
    // Check if it's a workspace import in a monorepo
    if (monorepoConfig && monorepoConfig.type !== 'none') {
        const currentPackage = (0, monorepo_1.findPackageForFile)(currentFilePath, monorepoConfig);
        const workspaceResolved = (0, monorepo_1.resolveWorkspaceImport)(importPath, currentPackage, monorepoConfig);
        if (workspaceResolved) {
            return workspaceResolved;
        }
    }
    // If it's a package import (not local), return null
    if (!isLocalImport(importPath) && !aliasMap.has(importPath.split('/')[0])) {
        return null;
    }
    // Resolve alias if present
    const resolvedImport = resolveImportPath(importPath, aliasMap);
    // If it's a relative import, resolve from current file
    let fullPath;
    if (resolvedImport.startsWith('.')) {
        const currentDir = path_1.default.dirname(currentFilePath);
        fullPath = path_1.default.resolve(currentDir, resolvedImport);
    }
    else if (resolvedImport.startsWith('/')) {
        fullPath = resolvedImport;
    }
    else {
        fullPath = path_1.default.resolve(projectRoot, resolvedImport);
    }
    // Try to resolve with common extensions
    const extensions = ['.ts', '.tsx', '.js', '.jsx', ''];
    for (const ext of extensions) {
        const testPath = fullPath + ext;
        if (fs_1.default.existsSync(testPath) && fs_1.default.statSync(testPath).isFile()) {
            return testPath;
        }
    }
    // Try index files
    for (const ext of ['.ts', '.tsx', '.js', '.jsx']) {
        const indexPath = path_1.default.join(fullPath, `index${ext}`);
        if (fs_1.default.existsSync(indexPath)) {
            return indexPath;
        }
    }
    return null;
}
